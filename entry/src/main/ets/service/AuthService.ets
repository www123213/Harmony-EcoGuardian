import { User } from '../model/User';
import { DataService } from './DataService';
import { cryptoFramework } from '@kit.CryptoArchitectureKit';

// æ¥å£å®šä¹‰
interface RegisterResult {
  success: boolean;
  message: string;
  user?: User;
}

interface LoginResult {
  success: boolean;
  message: string;
  user?: User;
}

interface ValidationResult {
  valid: boolean;
  message: string;
}

interface LogoutResult {
  success: boolean;
  message: string;
}

interface UpdateResult {
  success: boolean;
  message: string;
}

// è®¤è¯æœåŠ¡ç±»
export class AuthService {
  private static instance: AuthService;
  private dataService: DataService;

  private constructor() {
    this.dataService = DataService.getInstance();
  }

  public static getInstance(): AuthService {
    if (!AuthService.instance) {
      AuthService.instance = new AuthService();
    }
    return AuthService.instance;
  }

  // ç”¨æˆ·æ³¨å†Œ
  async register(username: string, email: string, password: string): Promise<RegisterResult> {
    try {
      console.log('å¼€å§‹æ³¨å†Œç”¨æˆ·:', email);
      
      // éªŒè¯è¾“å…¥
      const validation = this.validateInput(username, email, password);
      if (!validation.valid) {
        console.log('è¾“å…¥éªŒè¯å¤±è´¥:', validation.message);
        return { success: false, message: validation.message } as RegisterResult;
      }

      // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
      const existingUser = await this.dataService.getUserByEmail(email);
      if (existingUser) {
        console.log('é‚®ç®±å·²å­˜åœ¨:', email);
        return { success: false, message: 'è¯¥é‚®ç®±å·²è¢«æ³¨å†Œ' } as RegisterResult;
      }

      // åŠ å¯†å¯†ç 
      console.log('æ­£åœ¨åŠ å¯†å¯†ç ...');
      const hashedPassword = await this.hashPassword(password);
      
      // åˆ›å»ºæ–°ç”¨æˆ·
      const newUser = new User(username, email, password);
      newUser.password = hashedPassword; // è®¾ç½®åŠ å¯†åçš„å¯†ç 
      console.log('åˆ›å»ºæ–°ç”¨æˆ·å¯¹è±¡:', newUser.id, newUser.email);
      
      // ä¿å­˜ç”¨æˆ·
      console.log('æ­£åœ¨ä¿å­˜ç”¨æˆ·...');
      const saved = await this.dataService.saveUser(newUser);
      if (saved) {
        console.log('ç”¨æˆ·æ³¨å†ŒæˆåŠŸ:', email);
        return { success: true, message: 'æ³¨å†ŒæˆåŠŸ', user: newUser } as RegisterResult;
      } else {
        console.error('ç”¨æˆ·ä¿å­˜å¤±è´¥:', email);
        return { success: false, message: 'æ³¨å†Œå¤±è´¥ï¼Œè¯·é‡è¯•' } as RegisterResult;
      }
    } catch (error) {
      console.error('æ³¨å†Œå¤±è´¥:', error);
      return { success: false, message: 'æ³¨å†Œå¤±è´¥ï¼Œç³»ç»Ÿé”™è¯¯' } as RegisterResult;
    }
  }

  // ç”¨æˆ·ç™»å½•
  async login(email: string, password: string): Promise<LoginResult> {
    try {
      // éªŒè¯è¾“å…¥
      if (!email || !password) {
        return { success: false, message: 'è¯·è¾“å…¥é‚®ç®±å’Œå¯†ç ' } as LoginResult;
      }

      if (!this.isValidEmail(email)) {
        return { success: false, message: 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€' } as LoginResult;
      }

      // æŸ¥æ‰¾ç”¨æˆ·
      console.log('æ­£åœ¨æŸ¥æ‰¾ç”¨æˆ·:', email);
      const allUsers = await this.dataService.getUsers();
      console.log('å½“å‰ç³»ç»Ÿä¸­çš„ç”¨æˆ·æ€»æ•°:', allUsers.length);
      console.log('æ‰€æœ‰ç”¨æˆ·é‚®ç®±:', allUsers.map(u => u.email));
      
      const user = await this.dataService.getUserByEmail(email);
      if (!user) {
        console.error('ç”¨æˆ·ä¸å­˜åœ¨:', email);
        return { success: false, message: 'ç”¨æˆ·ä¸å­˜åœ¨' } as LoginResult;
      }
      
      console.log('æ‰¾åˆ°ç”¨æˆ·:', user.email);

      // éªŒè¯å¯†ç 
      const passwordValid = await this.verifyPassword(password, user.password);
      if (!passwordValid) {
        return { success: false, message: 'å¯†ç é”™è¯¯' } as LoginResult;
      }

      // è®¾ç½®å½“å‰ç”¨æˆ·
      await this.dataService.setCurrentUser(user);
      
      return { success: true, message: 'ç™»å½•æˆåŠŸ', user: user } as LoginResult;
    } catch (error) {
      console.error('ç™»å½•å¤±è´¥:', error);
      return { success: false, message: 'ç™»å½•å¤±è´¥ï¼Œç³»ç»Ÿé”™è¯¯' } as LoginResult;
    }
  }

  // ç”¨æˆ·ç™»å‡º
  async logout(): Promise<LogoutResult> {
    try {
      await this.dataService.logout();
      return { success: true, message: 'ç™»å‡ºæˆåŠŸ' } as LogoutResult;
    } catch (error) {
      console.error('ç™»å‡ºå¤±è´¥:', error);
      return { success: false, message: 'ç™»å‡ºå¤±è´¥' } as LogoutResult;
    }
  }

  // è·å–å½“å‰ç”¨æˆ·
  async getCurrentUser(forceRefresh: boolean = false): Promise<User | null> {
    try {
      if (forceRefresh) {
        // å¼ºåˆ¶ä»æ•°æ®æœåŠ¡è·å–æœ€æ–°ç”¨æˆ·æ•°æ®
        const currentUser = await this.dataService.getCurrentUser();
        if (currentUser) {
          // é‡æ–°ä»æ•°æ®åº“è·å–æœ€æ–°çš„ç”¨æˆ·æ•°æ®
          const freshUser = await this.dataService.getUserById(currentUser.id);
          if (freshUser) {
            // æ›´æ–°å½“å‰ç”¨æˆ·
            await this.dataService.setCurrentUser(freshUser);
            return freshUser;
          }
        }
        return null;
      }
      return await this.dataService.getCurrentUser();
    } catch (error) {
      console.error('è·å–å½“å‰ç”¨æˆ·å¤±è´¥:', error);
      return null;
    }
  }

  // æ›´æ–°ç”¨æˆ·ä¿¡æ¯
  async updateUserProfile(userId: string, updates: Partial<User>): Promise<UpdateResult> {
    try {
      const user = await this.dataService.getUserById(userId);
      if (!user) {
        return { success: false, message: 'ç”¨æˆ·ä¸å­˜åœ¨' } as LoginResult;
      }

      // æ›´æ–°ç”¨æˆ·ä¿¡æ¯
      if (updates.username !== undefined) user.username = updates.username;
      if (updates.email !== undefined) user.email = updates.email;
      if (updates.password !== undefined) user.password = updates.password;
      if (updates.avatar !== undefined) user.avatar = updates.avatar;
      if (updates.points !== undefined) user.points = updates.points;
      if (updates.carbonReduction !== undefined) user.carbonReduction = updates.carbonReduction;
      if (updates.level !== undefined) user.level = updates.level;
      if (updates.badges !== undefined) user.badges = updates.badges;
      if (updates.createdAt !== undefined) user.createdAt = updates.createdAt;
      
      const saved = await this.dataService.saveUser(user);
      if (saved) {
        // å¦‚æœæ˜¯å½“å‰ç”¨æˆ·ï¼Œæ›´æ–°å½“å‰ç”¨æˆ·ä¿¡æ¯
        const currentUser = await this.dataService.getCurrentUser();
        if (currentUser && currentUser.id === userId) {
          await this.dataService.setCurrentUser(user);
        }
        return { success: true, message: 'æ›´æ–°æˆåŠŸ' } as UpdateResult;
      } else {
        return { success: false, message: 'æ›´æ–°å¤±è´¥' } as UpdateResult;
      }
    } catch (error) {
      console.error('æ›´æ–°ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', error);
      return { success: false, message: 'æ›´æ–°å¤±è´¥ï¼Œç³»ç»Ÿé”™è¯¯' } as UpdateResult;
    }
  }

  // ä¿®æ”¹å¯†ç 
  async changePassword(userId: string, oldPassword: string, newPassword: string): Promise<UpdateResult> {
    try {
      const user = await this.dataService.getUserById(userId);
      if (!user) {
        return { success: false, message: 'ç”¨æˆ·ä¸å­˜åœ¨' } as LoginResult;
      }

      // éªŒè¯æ—§å¯†ç 
      const oldPasswordValid = await this.verifyPassword(oldPassword, user.password);
      if (!oldPasswordValid) {
        return { success: false, message: 'åŸå¯†ç é”™è¯¯' } as UpdateResult;
      }

      // éªŒè¯æ–°å¯†ç 
      if (!this.isValidPassword(newPassword)) {
        return { success: false, message: 'æ–°å¯†ç æ ¼å¼ä¸æ­£ç¡®ï¼Œè‡³å°‘6ä½å­—ç¬¦' } as UpdateResult;
      }

      // åŠ å¯†æ–°å¯†ç 
      const hashedNewPassword = await this.hashPassword(newPassword);
      user.password = hashedNewPassword;

      const saved = await this.dataService.saveUser(user);
      if (saved) {
        return { success: true, message: 'å¯†ç ä¿®æ”¹æˆåŠŸ' } as UpdateResult;
      } else {
        return { success: false, message: 'å¯†ç ä¿®æ”¹å¤±è´¥' } as UpdateResult;
      }
    } catch (error) {
      console.error('ä¿®æ”¹å¯†ç å¤±è´¥:', error);
      return { success: false, message: 'ä¿®æ”¹å¯†ç å¤±è´¥ï¼Œç³»ç»Ÿé”™è¯¯' } as UpdateResult;
    }
  }

  // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç™»å½•
  async isLoggedIn(): Promise<boolean> {
    const currentUser = await this.getCurrentUser();
    return currentUser !== null;
  }

  // è¾“å…¥éªŒè¯
  private validateInput(username: string, email: string, password: string): ValidationResult {
    if (!username || username.trim().length < 2) {
      return { valid: false, message: 'ç”¨æˆ·åè‡³å°‘2ä¸ªå­—ç¬¦' } as ValidationResult;
    }

    if (!email || !this.isValidEmail(email)) {
      return { valid: false, message: 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€' } as ValidationResult;
    }

    if (!password || !this.isValidPassword(password)) {
      return { valid: false, message: 'å¯†ç è‡³å°‘6ä½å­—ç¬¦' } as ValidationResult;
    }

    return { valid: true, message: '' } as ValidationResult;
  }

  // é‚®ç®±æ ¼å¼éªŒè¯
  private isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  // å¯†ç æ ¼å¼éªŒè¯
  private isValidPassword(password: string): boolean {
    return password.length >= 6;
  }

  // å¯†ç åŠ å¯†ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…é¡¹ç›®ä¸­åº”ä½¿ç”¨æ›´å®‰å…¨çš„åŠ å¯†æ–¹å¼ï¼‰
  private async hashPassword(password: string): Promise<string> {
    try {
      // ä½¿ç”¨ç®€å•çš„å­—ç¬¦ä¸²å“ˆå¸Œç®—æ³•
      let hash = 0;
      const saltedPassword = password + 'eco_app_salt';
      for (let i = 0; i < saltedPassword.length; i++) {
        const char = saltedPassword.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return Math.abs(hash).toString(16);
    } catch (error) {
      console.error('å¯†ç åŠ å¯†å¤±è´¥:', error);
      // é™çº§åˆ°ç®€å•ç¼–ç 
      return (password + 'eco_app_salt').split('').map(c => c.charCodeAt(0).toString(16)).join('');
    }
  }

  // å¯†ç éªŒè¯
  private async verifyPassword(password: string, hashedPassword: string): Promise<boolean> {
    try {
      const hashedInput = await this.hashPassword(password);
      return hashedInput === hashedPassword;
    } catch (error) {
      console.error('å¯†ç éªŒè¯å¤±è´¥:', error);
      return false;
    }
  }

  // ç”Ÿæˆéšæœºå¤´åƒï¼ˆå¯ä»¥æ‰©å±•ä¸ºé€‰æ‹©å¤´åƒåŠŸèƒ½ï¼‰
  generateRandomAvatar(): string {
    const avatars = [
      'ğŸŒ±', 'ğŸŒ¿', 'ğŸŒ³', 'ğŸŒ²', 'ğŸƒ', 'ğŸŒ¾', 'ğŸŒ»', 'ğŸŒº', 'ğŸŒ¸', 'ğŸŒ¼',
      'ğŸ', 'ğŸ¦‹', 'ğŸ›', 'ğŸ', 'ğŸŒ', 'ğŸŒ', 'ğŸŒ', 'â™»ï¸', 'ğŸŒˆ', 'â˜€ï¸'
    ];
    return avatars[Math.floor(Math.random() * avatars.length)];
  }

  // æ›´æ–°ç”¨æˆ·ä¿¡æ¯
  async updateUserInfo(updatedUser: User): Promise<void> {
    try {
      await this.dataService.saveUser(updatedUser);
      await this.dataService.setCurrentUser(updatedUser);
    } catch (error) {
      console.error('æ›´æ–°ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', error);
      throw new Error('æ›´æ–°ç”¨æˆ·ä¿¡æ¯å¤±è´¥');
    }
  }
}